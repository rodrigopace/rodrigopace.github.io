<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<html>
<head>
<meta charset="utf-8">


<title>Episode 3 – Things to Remember When using SSH in the Cloud &mdash; Head in the Clouds</title>
<meta name="description" content="3 – Things to Remember When using SSH in the Cloud



Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum.

Today’s episode is titled: “Things to Remember When using SSH in the Cloud”

The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations.

SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it.

In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier.


We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go.



Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance.



We will call this new key “demo” and here’s my one and only chance to download the key pair.  I’m going to save it into my downloads.
Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen?



When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning.



In subsequent connections, assuming that the DNS name has not changed, you should not see this message.
Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it.
I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file.



The warning indicates that the default permissions of 755 is way too open.
So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again.



Now the permissions are “read-only by the owner.”
And now, I should be able to connect to the EC2 Instance.



Also notice that I did not get the MITM warning because I’ve previously connected.
Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key:



Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key.



We can see that the text file starts with “private key” and ends “private key” as well.
Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators!
Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines?
Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console.



I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine.

Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.”



We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts.



I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that?

To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name.



Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.”
Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory.



Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS.



Notice that the key material is different.
Again the private key is something that you definitely want to make sure you have protected.

Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine.



Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file.

NOTE: To rotate the SSH Public Key, you would delete the original.
Now, we should be able to login with either one of our keys.



Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure.


We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string:



We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys.
The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch:



We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory.
When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command:



Important Points
Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines.

In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file).



Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound.

Wrap Up

My hope is that that information is helped you up your cloud game when it comes to SSH.
Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta name="keywords" content="">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Episode 3 – Things to Remember When using SSH in the Cloud">
<meta name="twitter:description" content="3 – Things to Remember When using SSH in the Cloud



Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum.

Today’s episode is titled: “Things to Remember When using SSH in the Cloud”

The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations.

SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it.

In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier.


We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go.



Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance.



We will call this new key “demo” and here’s my one and only chance to download the key pair.  I’m going to save it into my downloads.
Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen?



When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning.



In subsequent connections, assuming that the DNS name has not changed, you should not see this message.
Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it.
I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file.



The warning indicates that the default permissions of 755 is way too open.
So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again.



Now the permissions are “read-only by the owner.”
And now, I should be able to connect to the EC2 Instance.



Also notice that I did not get the MITM warning because I’ve previously connected.
Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key:



Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key.



We can see that the text file starts with “private key” and ends “private key” as well.
Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators!
Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines?
Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console.



I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine.

Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.”



We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts.



I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that?

To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name.



Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.”
Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory.



Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS.



Notice that the key material is different.
Again the private key is something that you definitely want to make sure you have protected.

Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine.



Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file.

NOTE: To rotate the SSH Public Key, you would delete the original.
Now, we should be able to login with either one of our keys.



Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure.


We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string:



We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys.
The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch:



We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory.
When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command:



Important Points
Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines.

In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file).



Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound.

Wrap Up

My hope is that that information is helped you up your cloud game when it comes to SSH.
Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta name="twitter:site" content="@kennethghartman">
<meta name="twitter:creator" content="@kennethghartman">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/default-thumb.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Episode 3 – Things to Remember When using SSH in the Cloud">
<meta property="og:description" content="3 – Things to Remember When using SSH in the Cloud



Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum.

Today’s episode is titled: “Things to Remember When using SSH in the Cloud”

The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations.

SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it.

In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier.


We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go.



Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance.



We will call this new key “demo” and here’s my one and only chance to download the key pair.  I’m going to save it into my downloads.
Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen?



When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning.



In subsequent connections, assuming that the DNS name has not changed, you should not see this message.
Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it.
I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file.



The warning indicates that the default permissions of 755 is way too open.
So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again.



Now the permissions are “read-only by the owner.”
And now, I should be able to connect to the EC2 Instance.



Also notice that I did not get the MITM warning because I’ve previously connected.
Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key:



Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key.



We can see that the text file starts with “private key” and ends “private key” as well.
Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators!
Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines?
Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console.



I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine.

Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.”



We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts.



I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that?

To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name.



Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.”
Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory.



Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS.



Notice that the key material is different.
Again the private key is something that you definitely want to make sure you have protected.

Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine.



Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file.

NOTE: To rotate the SSH Public Key, you would delete the original.
Now, we should be able to login with either one of our keys.



Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure.


We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string:



We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys.
The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch:



We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory.
When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command:



Important Points
Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines.

In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file).



Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound.

Wrap Up

My hope is that that information is helped you up your cloud game when it comes to SSH.
Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta property="og:url" content="/episodes/episode03/">
<meta property="og:site_name" content="Head in the Clouds">

<meta property="og:image" content="/images/default-thumb.png">






<link rel="canonical" href="/episodes/episode03/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Head in the Clouds Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">


<meta http-equiv="cleartype" content="on">


<!-- Modernizr -->
<script src="/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/css/academicons/css/academicons.css"/>
<!-- Icons -->
<!-- 16x16 -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!--Jekyll-seo plugin-->
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Episode 3 – Things to Remember When using SSH in the Cloud | Head in the Clouds</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Episode 3 – Things to Remember When using SSH in the Cloud" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="3 – Things to Remember When using SSH in the Cloud Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum. Today’s episode is titled: “Things to Remember When using SSH in the Cloud” The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations. SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it. In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier. We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go. Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance. We will call this new key “demo” and here’s my one and only chance to download the key pair. I’m going to save it into my downloads. Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen? When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning. In subsequent connections, assuming that the DNS name has not changed, you should not see this message. Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it. I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file. The warning indicates that the default permissions of 755 is way too open. So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again. Now the permissions are “read-only by the owner.” And now, I should be able to connect to the EC2 Instance. Also notice that I did not get the MITM warning because I’ve previously connected. Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key: Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key. We can see that the text file starts with “private key” and ends “private key” as well. Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators! Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines? Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console. I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine. Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.” We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts. I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that? To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name. Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.” Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory. Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS. Notice that the key material is different. Again the private key is something that you definitely want to make sure you have protected. Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine. Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file. NOTE: To rotate the SSH Public Key, you would delete the original. Now, we should be able to login with either one of our keys. Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure. We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string: We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys. The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch: We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory. When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command: Important Points Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines. In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file). Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound. Wrap Up My hope is that that information is helped you up your cloud game when it comes to SSH. Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care." />
<meta property="og:description" content="3 – Things to Remember When using SSH in the Cloud Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum. Today’s episode is titled: “Things to Remember When using SSH in the Cloud” The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations. SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it. In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier. We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go. Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance. We will call this new key “demo” and here’s my one and only chance to download the key pair. I’m going to save it into my downloads. Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen? When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning. In subsequent connections, assuming that the DNS name has not changed, you should not see this message. Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it. I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file. The warning indicates that the default permissions of 755 is way too open. So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again. Now the permissions are “read-only by the owner.” And now, I should be able to connect to the EC2 Instance. Also notice that I did not get the MITM warning because I’ve previously connected. Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key: Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key. We can see that the text file starts with “private key” and ends “private key” as well. Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators! Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines? Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console. I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine. Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.” We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts. I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that? To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name. Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.” Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory. Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS. Notice that the key material is different. Again the private key is something that you definitely want to make sure you have protected. Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine. Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file. NOTE: To rotate the SSH Public Key, you would delete the original. Now, we should be able to login with either one of our keys. Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure. We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string: We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys. The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch: We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory. When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command: Important Points Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines. In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file). Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound. Wrap Up My hope is that that information is helped you up your cloud game when it comes to SSH. Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care." />
<link rel="canonical" href="http://localhost:4000/episodes/episode03/" />
<meta property="og:url" content="http://localhost:4000/episodes/episode03/" />
<meta property="og:site_name" content="Head in the Clouds" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-24T15:17:05-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Episode 3 – Things to Remember When using SSH in the Cloud" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-24T14:59:38-03:00","datePublished":"2022-05-24T15:17:05-03:00","description":"3 – Things to Remember When using SSH in the Cloud Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum. Today’s episode is titled: “Things to Remember When using SSH in the Cloud” The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations. SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it. In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier. We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another Head in the Cloud session topic. I am just calling that out as we go. Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance. We will call this new key “demo” and here’s my one and only chance to download the key pair. I’m going to save it into my downloads. Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen? When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning. In subsequent connections, assuming that the DNS name has not changed, you should not see this message. Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it. I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my demo.pem file. The warning indicates that the default permissions of 755 is way too open. So, lets run a ls -als and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run chmod 400 demo.pem and look at the permissions again. Now the permissions are “read-only by the owner.” And now, I should be able to connect to the EC2 Instance. Also notice that I did not get the MITM warning because I’ve previously connected. Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key: Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use cat demo.pem to examine the key. We can see that the text file starts with “private key” and ends “private key” as well. Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators! Let me ask you if everybody’s logging in ec2-user using the same private key, how do you have accountability for who is making what changes on your virtual machines? Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console. I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine. Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.” We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts. I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that? To generate a public-private key pair, we use the ssh-keygen command. You need to provide a location and file name. Notice that, by default it is stored in the SSH directory and given a name of id_rsa but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.” Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory. Now if we do an ls we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the demo2 file has a very similar structure to the other private key that was generated by AWS. Notice that the key material is different. Again the private key is something that you definitely want to make sure you have protected. Next, take a look at our demo2.pub key file. It looks very much like that authorized_keys file that we saw on our virtual machine. Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing authorized_keys file. NOTE: To rotate the SSH Public Key, you would delete the original. Now, we should be able to login with either one of our keys. Now we have authenticated with the other private key. While we are still logged in, let’s take a look at /var/log/secure. We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string: We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys. The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use ssh-keygen command with the -lf switch: We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory. When we do a ls we can see that we have the authorized_keys file, so here again we use the keygen command: Important Points Never forget that the point of this exercise is that you have to monitor your SSH authentication logs, not just for the username but also the SSH key hash that was used, and yes, the public key is public but don’t let an attacker insert their public key into your virtual machines. In addition, you may want to use file integrity monitoring for your .ssh folder (or at least your authorized_keys file). Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound. Wrap Up My hope is that that information is helped you up your cloud game when it comes to SSH. Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care.","headline":"Episode 3 – Things to Remember When using SSH in the Cloud","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/episodes/episode03/"},"url":"http://localhost:4000/episodes/episode03/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K6EX94SG73"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K6EX94SG73');
</script>


</head>

<body class="page">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		
		<a href="/">Head in the Clouds</a>
		
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				    
				    <li><a href="/" >Home</a></li>
				
				    
				    <li><a href="/episodes/" >All Episodes</a></li>
				
				    
				    <li><a href="https://www.sans.org/cyber-security-courses/?focus-area=cloud-security" target="_blank">SANS CyberSec Courses & Certs</a></li>
				
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main">
  <div class="article-author-side">
    

<div itemscope itemtype="https://schema.org/Person">


	<img src="/images/Cloud_Ace_Final.png" class="bio-photo" alt="Head in the Clouds bio photo">


  <h3 itemprop="name">Head in the Clouds</h3>
  <p>with Kenneth G. Hartman<p>Certified SANS Instructor</p>
  <a href="mailto:kgh@kennethghartman.com" class="author-social" target="_blank"><i class="fa fa-fw fa-envelope-square"></i> Email</a>
  <a href="https://twitter.com/kennethghartman" class="author-social" target="_blank"><i class="fa fa-fw fa-twitter-square"></i> Twitter</a>
  
  
  
  
  
  
  
  <a href="https://github.com/Resistor52" class="author-social" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </div>
  <article class="page">
    <h1>Episode 3 – Things to Remember When using SSH in the Cloud</h1>
    <div class="article-wrap">
      <p>3 – Things to Remember When using SSH in the Cloud</p>

<div class="video-container"><iframe src="https://www.youtube.com/embed/H32e5x1w41E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>

<p>Welcome to Episode 3 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Curriculum.</p>

<p>Today’s episode is titled: “Things to Remember When using SSH in the Cloud”</p>

<p>The major cloud service providers have made it so easy to use SSH to connect to their virtual machines, that it can be easy to forget some of the security implications. In today’s session, we are going to review some SSH concepts and then we will highlight some important security considerations.</p>

<p>SSH works pretty much the same for the big three CSPs. Let’s start by taking a look at AWS. For those of you who have launched a thousand virtual machines, this may feel like a review. But we are going to slow down and talk about all that is going on behind the scenes and be mindful of security as we do it.</p>

<p>In AWS EC2 Console, we are going to launch the default Amazon Linux AMI and choose the T2.Micro as it is part of the free tier.</p>

<p><img src="/images/ep3/Picture1.png" alt="Image of the AWS EC2 console" />
We are just going to let it create a new security group, which many people do–but notice it has have SSH open to the world. That is a whole other set of issues and possibly another <em>Head in the Cloud</em> session topic. I am just calling that out as we go.</p>

<p><img src="/images/ep3/Picture2.png" alt="Image of the Configure Security Group step" /></p>

<p>Next, I will click “launch” and it’s at this point that we get the opportunity to use an existing key pair or to have AWS create a new key pair for our instance.</p>

<p><img src="/images/ep3/Picture3.png" alt="Image of the Create a New Key Pair step" /></p>

<p>We will call this new key “demo” and here’s my one and only chance to download the key pair.  I’m going to save it into my downloads.
Once the VM has launched, I will cd into my downloads directory…and there is my key. Now, if I paste the SSH connection string I may or may not be able to connect…what’s going to happen?</p>

<p><img src="/images/ep3/Picture4.png" alt="Image of the terminal running SSH" /></p>

<p>When you see this message, it is intended to prevent a man-in-the-middle attack. So, the very first time that you connect to an EC2 instance (or any remote host for that matter) you should expect to see this warning.</p>

<p><img src="/images/ep3/Picture5.png" alt="Image of the terminal displaying a SSH MiTM Warning" /></p>

<p>In subsequent connections, assuming that the DNS name has not changed, you should not see this message.
Don’t just mindlessly blow past this warning! Think about what it’s telling you, and one of the things that it’s doing is it’s providing you with the fingerprint for the key and then the SSH client adds that a file to keep track of it.
I am going to say “yes” and then—Oops! …I’m getting a warning. The reason why I’m getting a warning is because I don’t have the appropriate permissions on my <strong>demo.pem</strong> file.</p>

<p><img src="/images/ep3/Picture6.png" alt="Image of the terminal displaying Unprotected Private Key File warning" /></p>

<p>The warning indicates that the default permissions of 755 is way too open.
So, lets run a <code class="language-plaintext highlighter-rouge">ls -als</code> and take a much closer look. Now, we can see the permissions. What I need to do is change to 400 permissions. So, I run <code class="language-plaintext highlighter-rouge">chmod 400 demo.pem</code> and look at the permissions again.</p>

<p><img src="/images/ep3/Picture7.png" alt="Image of the terminal running the chmod command" /></p>

<p>Now the permissions are “read-only by the owner.”
And now, I should be able to connect to the EC2 Instance.</p>

<p><img src="/images/ep3/Picture8.png" alt="Image of the terminal with a successful SSH connection" /></p>

<p>Also notice that I did not get the MITM warning because I’ve previously connected.
Alright, so we’ve authenticated to our easy to instance using SSH public key authentication. Now let’s take a look at the public key. We can see that it is an RSA type of key, and here is the public key:</p>

<p><img src="/images/ep3/Picture9.png" alt="Image of the terminal with a successful SSH connection" /></p>

<p>Next, let’s take a look at the private key. To do that, I need exit back out. I am still in my downloads directory so I can use <code class="language-plaintext highlighter-rouge">cat demo.pem</code> to examine the key.</p>

<p><img src="/images/ep3/Picture10.png" alt="Image of the terminal displaying an RSA Private Key" /></p>

<p>We can see that the text file starts with “private key” and ends “private key” as well.
Now this key should be carefully protected and of course even though I showed it to you, I will be deleting it immediately after this recording, but I’ve seen various organizations make copies of their private keys and upload them to their box.com account, for example, and share it across multiple production operators!
Let me ask you if everybody’s logging in <strong>ec2-user</strong> using the same private key, how do you have accountability for <em>who</em> is making <em>what</em> changes on your virtual machines?
Okay the next thing that I wanted to do was take a look and see what the public key looks like in the console.</p>

<p><img src="/images/ep3/Picture11.png" alt="Image of SSH key Pairs in the AWS EC2 Console" /></p>

<p>I can see that I have a pre-existing key (from prior to the launching the virtual machine) and I have the key that was made when I launched this virtual machine, but by just looking at this I cannot tell which key is older than the other and this has been a frustration of mine.</p>

<p>Fortunately, AWS has added the ability to tag the key, so I would recommend that you do is to tag the key with its “create date.”</p>

<p><img src="/images/ep3/Picture12.png" alt="Image of the EC2 console, adding a tag to the Key Pair" /></p>

<p>We can also have it display in the console, and this may help you with key management because you need to be rotating your SSH key pairs, just like you would rotate your AWS access keys and your passwords for all user accounts.</p>

<p><img src="/images/ep3/Picture13.png" alt="Image of the EC2 Console displaying the CreateDate tag in the Key Pairs view" /></p>

<p>I can tell you that in many organizations the SSH keys are neglected. If it’s so important to rotate your keys, how does one to go about doing that?</p>

<p>To generate a public-private key pair, we use the <code class="language-plaintext highlighter-rouge">ssh-keygen</code> command. You need to provide a location and file name.</p>

<p><img src="/images/ep3/Picture14.png" alt="Image of the terminal running the ssh-keygen command" /></p>

<p>Notice that, by default it is stored in the SSH directory and given a name of <code class="language-plaintext highlighter-rouge">id_rsa</code> but I wanted it to be in the current directory. So, I use a single period and then, give it the name of “demo2.”
Next, I’m prompted for a passphrase. A passphrase protects the private key above and beyond the operating system protections due to the fact that creating it in my home directory.</p>

<p><img src="/images/ep3/Picture15.png" alt="Image of the terminal displaying the names of public and private keys" /></p>

<p>Now if we do an <code class="language-plaintext highlighter-rouge">ls</code> we will see that we have two new files. One is called “demo2” which is my private key. Notice that the command didn’t attack on the “pem” file extension? That is something that AWS does, but we see the <code class="language-plaintext highlighter-rouge">demo2</code> file has a very similar structure to the other private key that was generated by AWS.</p>

<p><img src="/images/ep3/Picture16.png" alt="Image of the terminal displaying the contents of the demo2 private key" /></p>

<p>Notice that the key material is different.
Again the private key is something that you definitely want to make sure you have protected.</p>

<p>Next, take a look at our <code class="language-plaintext highlighter-rouge">demo2.pub</code> key file. It looks very much like that <code class="language-plaintext highlighter-rouge">authorized_keys</code> file that we saw on our virtual machine.</p>

<p><img src="/images/ep3/Picture17.png" alt="Image of the terminal displaying the contents of the demo2.pub public key" /></p>

<p>Let’s insert this new public key into our virtual machine. The easiest way is just to copy it and then SSH in and append the copied contents onto the existing <code class="language-plaintext highlighter-rouge">authorized_keys</code> file.</p>

<p><strong>NOTE:</strong> To rotate the SSH Public Key, you would delete the original.
Now, we should be able to login with either one of our keys.</p>

<p><img src="/images/ep3/Picture18.png" alt="Image of the terminal displaying the SSH connection string using the demo2 private key" /></p>

<p>Now we have authenticated with the other private key. While we are still logged in, let’s take a look at <code class="language-plaintext highlighter-rouge">/var/log/secure</code>.</p>

<p><img src="/images/ep3/Picture19.png" alt="Image of the terminal displaying a portion of /var/log/secure" />
We can see that we’ve got multiple times where we have a message that says “Accepted public key for ec2-user.” So let’s go ahead and do a grep for that string:</p>

<p><img src="/images/ep3/Picture20.png" alt="Image of the terminal displaying the results of a grep command" /></p>

<p>We can see that we have two different SHA256 values. Where did those two different SHA256 values come from? They are the SHA256 hash of the public keys.
The easiest way to demonstrate that is, if we exit out of our SSH session and then we can use <code class="language-plaintext highlighter-rouge">ssh-keygen</code> command with the <code class="language-plaintext highlighter-rouge">-lf</code> switch:</p>

<p><img src="/images/ep3/Picture21.png" alt="Image of the terminal displaying the output of the ssh-keygen command" /></p>

<p>We can see that it does indeed match. What about the other one? Well, we don’t have a local copy of that one. So, let’s log back into our EC2 instance and change into our .ssh directory.
When we do a <code class="language-plaintext highlighter-rouge">ls</code> we can see that we have the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file, so here again we use the <code class="language-plaintext highlighter-rouge">keygen</code> command:</p>

<p><img src="/images/ep3/Picture22.png" alt="Image of the terminal displaying the output of the ssh-keygen command" /></p>

<h2 id="important-points">Important Points</h2>
<p>Never forget that the point of this exercise is that <strong>you have to monitor your SSH authentication logs</strong>, not just for the username but also the SSH key hash that was used, and yes, the public key is <em>public</em> but don’t let an attacker insert their public key into your virtual machines.</p>

<p>In addition, you may want to use file integrity monitoring for your <code class="language-plaintext highlighter-rouge">.ssh</code> folder (or at least your <code class="language-plaintext highlighter-rouge">authorized_keys</code> file).</p>

<p><img src="/images/ep3/Picture22.png" alt="Image of the slide summarizing important points" /></p>

<p>Also, it’s very important to know the scope, age, and the provenance of all SSH keys on all of your systems as well as to which identities each key is bound.</p>

<h2 id="wrap-up">Wrap Up</h2>

<p>My hope is that that information is helped you up your cloud game when it comes to SSH.
Also, if you can—avoid SSH completely. The major cloud service providers each have provided options (but each option is different) so that you can avoid having to manage SSH keys across your cloud fleet.</p>

<p>If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to <a href="mailto://head-in-the-clouds-security@googlegroups.com">head-in-the-clouds-security@googlegroups.com</a>.</p>

<p>Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the <a href="https://twitter.com/SANSCloudSec">SANS Cloud Security Twitter feed</a>.</p>

<p>Meanwhile, be sure to check out the other great videos on the <a href="https://www.youtube.com/c/SANSCloudSecurity">SANS Cloud Security YouTube Channel</a>.</p>

<p>Take care.</p>

      
        <hr />
        <div class="social-share">
  <!--<h4>Share on</h4>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=/episodes/episode03/" class="twitter" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=/episodes/episode03/" class="facebook" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=/episodes/episode03/" class="google-plus" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
  </ul>-->
</div><!-- /.social-share -->

      
    </div><!-- /.article-wrap -->
    
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    

<span>&copy; 2022 Head in the Clouds.<br /></span>


  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-25220220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




</body>
</html>
