<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<html>
<head>
<meta charset="utf-8">


<title>Episode 4 - Use Terraform to Provision a Google Compute instance &mdash; Head in the Clouds</title>
<meta name="description" content="4 - Use Terraform to Provision a Google Compute instance



Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Use Terraform to Provision a Google Compute instance”

This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code.

Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance.

That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently.

Generate a SSH Key Pair for Use in this Demo

First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like:

ubuntu@ubuntu:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223
The key's randomart image is:
+---[RSA 3072]----+
|          o.@Xo  |
|       o o O+*E  |
|      o * X o    |
|       B = =     |
|      + S + +    |
|     . + = =     |
|      . o * .    |
|       o.+ o     |
|       .+*= .    |
+----[SHA256]-----+



This creates the two files in the .ssh directory:

  id_rsa
  id_rsa.pub


We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown:

ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu


Note that your public key material will be different than what is shown above.

This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance.

Create a GCP Project and a Service Account

Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique.



Create a service account named “terraform”



Attach the “Compute Admin” role to the service account.



Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.”

Select “JSON” as the format and click “CREATE.”



This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected.

NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted.



Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json”

For more information see Getting started with Terraform on Google Cloud.

Enable The GCE Service

Since this is a new project, we will need to enable the GCE service via the web console.



Install Terraform

Run the following commands to download and install terraform:

sudo apt install -y unzip
wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip
sudo unzip /tmp/terraform.zip -d /usr/local/bin/
rm /tmp/terraform.zip


confirm the version and execution:

terraform --version


You should see the following:

ubuntu@unbuntu:~$ terraform --version
Terraform v0.15.1
on linux_amd64


Create main.tf file

Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode):

variable "gce_ssh_user" {}
variable "gce_ssh_pub_key_file" {}
variable "gcp_project" {}
variable "gcp_region" {}
variable "gcp_zone" {}
variable "gcp_key_file" {}

provider "google" {
  credentials = file(var.gcp_key_file)
  project = var.gcp_project
  region  = var.gcp_region
  zone    = var.gcp_zone
}

resource "google_compute_address" "static" {
  name = "ipv4-address"
}

resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"

  boot_disk {
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-2004-focal-v20210415"
    }
  }

  network_interface {
    network = google_compute_network.vpc_network.self_link
    access_config {
      nat_ip = google_compute_address.static.address
      }
  }

metadata = {
  sshKeys = "${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}"
  }

tags = ["ssh-server"]

}

resource "google_compute_network" "vpc_network" {
  name                    = "vpc-network"
  auto_create_subnetworks = "true"
}

resource "google_compute_firewall" "ssh-server" {
  name    = "default-allow-ssh-terraform"
  network = google_compute_network.vpc_network.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  // Allow traffic from everywhere to instances with an ssh-server tag
  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

output "ip" {
  value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip
}



Create terraform.tfvars file

Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode):

gce_ssh_user ="sans"
gce_ssh_pub_key_file = "~/.ssh/id_rsa.pub"
gcp_project = "PROJECT_ID"
gcp_region  = "us-central1"
gcp_zone    = "us-central1-a"
gcp_key_file = "~/accesskey/service_account.json"



NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo.

Perform Initial Deployment

Run the following command to initialize terraform:

terraform init


You will see something like:

ubuntu@ubuntu:~$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/google...
- Installing hashicorp/google v3.65.0...
- Installed hashicorp/google v3.65.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.



Now push out the configuration to GCP:

terraform apply


Upon completion, we will see results that look similar to:



SSH into the new GCE instance

SSH into the GCE instance using the following command but substituting the output of the
terraform script to “IP_ADDRESS”

ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS


Clean up
Now that we have completed the demo, clean up by doing the following:

  Exit from the SSH Session
  Run terraform destroy to tear down the GCE resources
  Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN”


Wrap Up

That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta name="keywords" content="">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Episode 4 - Use Terraform to Provision a Google Compute instance">
<meta name="twitter:description" content="4 - Use Terraform to Provision a Google Compute instance



Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Use Terraform to Provision a Google Compute instance”

This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code.

Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance.

That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently.

Generate a SSH Key Pair for Use in this Demo

First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like:

ubuntu@ubuntu:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223
The key's randomart image is:
+---[RSA 3072]----+
|          o.@Xo  |
|       o o O+*E  |
|      o * X o    |
|       B = =     |
|      + S + +    |
|     . + = =     |
|      . o * .    |
|       o.+ o     |
|       .+*= .    |
+----[SHA256]-----+



This creates the two files in the .ssh directory:

  id_rsa
  id_rsa.pub


We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown:

ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu


Note that your public key material will be different than what is shown above.

This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance.

Create a GCP Project and a Service Account

Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique.



Create a service account named “terraform”



Attach the “Compute Admin” role to the service account.



Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.”

Select “JSON” as the format and click “CREATE.”



This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected.

NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted.



Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json”

For more information see Getting started with Terraform on Google Cloud.

Enable The GCE Service

Since this is a new project, we will need to enable the GCE service via the web console.



Install Terraform

Run the following commands to download and install terraform:

sudo apt install -y unzip
wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip
sudo unzip /tmp/terraform.zip -d /usr/local/bin/
rm /tmp/terraform.zip


confirm the version and execution:

terraform --version


You should see the following:

ubuntu@unbuntu:~$ terraform --version
Terraform v0.15.1
on linux_amd64


Create main.tf file

Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode):

variable "gce_ssh_user" {}
variable "gce_ssh_pub_key_file" {}
variable "gcp_project" {}
variable "gcp_region" {}
variable "gcp_zone" {}
variable "gcp_key_file" {}

provider "google" {
  credentials = file(var.gcp_key_file)
  project = var.gcp_project
  region  = var.gcp_region
  zone    = var.gcp_zone
}

resource "google_compute_address" "static" {
  name = "ipv4-address"
}

resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"

  boot_disk {
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-2004-focal-v20210415"
    }
  }

  network_interface {
    network = google_compute_network.vpc_network.self_link
    access_config {
      nat_ip = google_compute_address.static.address
      }
  }

metadata = {
  sshKeys = "${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}"
  }

tags = ["ssh-server"]

}

resource "google_compute_network" "vpc_network" {
  name                    = "vpc-network"
  auto_create_subnetworks = "true"
}

resource "google_compute_firewall" "ssh-server" {
  name    = "default-allow-ssh-terraform"
  network = google_compute_network.vpc_network.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  // Allow traffic from everywhere to instances with an ssh-server tag
  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

output "ip" {
  value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip
}



Create terraform.tfvars file

Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode):

gce_ssh_user ="sans"
gce_ssh_pub_key_file = "~/.ssh/id_rsa.pub"
gcp_project = "PROJECT_ID"
gcp_region  = "us-central1"
gcp_zone    = "us-central1-a"
gcp_key_file = "~/accesskey/service_account.json"



NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo.

Perform Initial Deployment

Run the following command to initialize terraform:

terraform init


You will see something like:

ubuntu@ubuntu:~$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/google...
- Installing hashicorp/google v3.65.0...
- Installed hashicorp/google v3.65.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.



Now push out the configuration to GCP:

terraform apply


Upon completion, we will see results that look similar to:



SSH into the new GCE instance

SSH into the GCE instance using the following command but substituting the output of the
terraform script to “IP_ADDRESS”

ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS


Clean up
Now that we have completed the demo, clean up by doing the following:

  Exit from the SSH Session
  Run terraform destroy to tear down the GCE resources
  Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN”


Wrap Up

That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta name="twitter:site" content="@kennethghartman">
<meta name="twitter:creator" content="@kennethghartman">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/default-thumb.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Episode 4 - Use Terraform to Provision a Google Compute instance">
<meta property="og:description" content="4 - Use Terraform to Provision a Google Compute instance



Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Use Terraform to Provision a Google Compute instance”

This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code.

Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance.

That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently.

Generate a SSH Key Pair for Use in this Demo

First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like:

ubuntu@ubuntu:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223
The key's randomart image is:
+---[RSA 3072]----+
|          o.@Xo  |
|       o o O+*E  |
|      o * X o    |
|       B = =     |
|      + S + +    |
|     . + = =     |
|      . o * .    |
|       o.+ o     |
|       .+*= .    |
+----[SHA256]-----+



This creates the two files in the .ssh directory:

  id_rsa
  id_rsa.pub


We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown:

ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu


Note that your public key material will be different than what is shown above.

This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance.

Create a GCP Project and a Service Account

Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique.



Create a service account named “terraform”



Attach the “Compute Admin” role to the service account.



Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.”

Select “JSON” as the format and click “CREATE.”



This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected.

NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted.



Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json”

For more information see Getting started with Terraform on Google Cloud.

Enable The GCE Service

Since this is a new project, we will need to enable the GCE service via the web console.



Install Terraform

Run the following commands to download and install terraform:

sudo apt install -y unzip
wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip
sudo unzip /tmp/terraform.zip -d /usr/local/bin/
rm /tmp/terraform.zip


confirm the version and execution:

terraform --version


You should see the following:

ubuntu@unbuntu:~$ terraform --version
Terraform v0.15.1
on linux_amd64


Create main.tf file

Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode):

variable "gce_ssh_user" {}
variable "gce_ssh_pub_key_file" {}
variable "gcp_project" {}
variable "gcp_region" {}
variable "gcp_zone" {}
variable "gcp_key_file" {}

provider "google" {
  credentials = file(var.gcp_key_file)
  project = var.gcp_project
  region  = var.gcp_region
  zone    = var.gcp_zone
}

resource "google_compute_address" "static" {
  name = "ipv4-address"
}

resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"

  boot_disk {
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-2004-focal-v20210415"
    }
  }

  network_interface {
    network = google_compute_network.vpc_network.self_link
    access_config {
      nat_ip = google_compute_address.static.address
      }
  }

metadata = {
  sshKeys = "${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}"
  }

tags = ["ssh-server"]

}

resource "google_compute_network" "vpc_network" {
  name                    = "vpc-network"
  auto_create_subnetworks = "true"
}

resource "google_compute_firewall" "ssh-server" {
  name    = "default-allow-ssh-terraform"
  network = google_compute_network.vpc_network.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  // Allow traffic from everywhere to instances with an ssh-server tag
  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

output "ip" {
  value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip
}



Create terraform.tfvars file

Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode):

gce_ssh_user ="sans"
gce_ssh_pub_key_file = "~/.ssh/id_rsa.pub"
gcp_project = "PROJECT_ID"
gcp_region  = "us-central1"
gcp_zone    = "us-central1-a"
gcp_key_file = "~/accesskey/service_account.json"



NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo.

Perform Initial Deployment

Run the following command to initialize terraform:

terraform init


You will see something like:

ubuntu@ubuntu:~$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/google...
- Installing hashicorp/google v3.65.0...
- Installed hashicorp/google v3.65.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.



Now push out the configuration to GCP:

terraform apply


Upon completion, we will see results that look similar to:



SSH into the new GCE instance

SSH into the GCE instance using the following command but substituting the output of the
terraform script to “IP_ADDRESS”

ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS


Clean up
Now that we have completed the demo, clean up by doing the following:

  Exit from the SSH Session
  Run terraform destroy to tear down the GCE resources
  Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN”


Wrap Up

That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform.

If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.
">
<meta property="og:url" content="/episodes/episode04/">
<meta property="og:site_name" content="Head in the Clouds">

<meta property="og:image" content="/images/default-thumb.png">






<link rel="canonical" href="/episodes/episode04/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Head in the Clouds Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">


<meta http-equiv="cleartype" content="on">


<!-- Modernizr -->
<script src="/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/css/academicons/css/academicons.css"/>
<!-- Icons -->
<!-- 16x16 -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!--Jekyll-seo plugin-->
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Episode 4 - Use Terraform to Provision a Google Compute instance | Head in the Clouds</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Episode 4 - Use Terraform to Provision a Google Compute instance" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="4 - Use Terraform to Provision a Google Compute instance Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Use Terraform to Provision a Google Compute instance” This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code. Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance. That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently. Generate a SSH Key Pair for Use in this Demo First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like: ubuntu@ubuntu:~$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/ubuntu/.ssh/id_rsa Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub The key fingerprint is: SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223 The key&#39;s randomart image is: +---[RSA 3072]----+ | o.@Xo | | o o O+*E | | o * X o | | B = = | | + S + + | | . + = = | | . o * . | | o.+ o | | .+*= . | +----[SHA256]-----+ This creates the two files in the .ssh directory: id_rsa id_rsa.pub We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown: ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu Note that your public key material will be different than what is shown above. This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance. Create a GCP Project and a Service Account Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique. Create a service account named “terraform” Attach the “Compute Admin” role to the service account. Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.” Select “JSON” as the format and click “CREATE.” This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected. NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted. Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json” For more information see Getting started with Terraform on Google Cloud. Enable The GCE Service Since this is a new project, we will need to enable the GCE service via the web console. Install Terraform Run the following commands to download and install terraform: sudo apt install -y unzip wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip sudo unzip /tmp/terraform.zip -d /usr/local/bin/ rm /tmp/terraform.zip confirm the version and execution: terraform --version You should see the following: ubuntu@unbuntu:~$ terraform --version Terraform v0.15.1 on linux_amd64 Create main.tf file Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode): variable &quot;gce_ssh_user&quot; {} variable &quot;gce_ssh_pub_key_file&quot; {} variable &quot;gcp_project&quot; {} variable &quot;gcp_region&quot; {} variable &quot;gcp_zone&quot; {} variable &quot;gcp_key_file&quot; {} provider &quot;google&quot; { credentials = file(var.gcp_key_file) project = var.gcp_project region = var.gcp_region zone = var.gcp_zone } resource &quot;google_compute_address&quot; &quot;static&quot; { name = &quot;ipv4-address&quot; } resource &quot;google_compute_instance&quot; &quot;vm_instance&quot; { name = &quot;terraform-instance&quot; machine_type = &quot;f1-micro&quot; boot_disk { initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-2004-focal-v20210415&quot; } } network_interface { network = google_compute_network.vpc_network.self_link access_config { nat_ip = google_compute_address.static.address } } metadata = { sshKeys = &quot;${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}&quot; } tags = [&quot;ssh-server&quot;] } resource &quot;google_compute_network&quot; &quot;vpc_network&quot; { name = &quot;vpc-network&quot; auto_create_subnetworks = &quot;true&quot; } resource &quot;google_compute_firewall&quot; &quot;ssh-server&quot; { name = &quot;default-allow-ssh-terraform&quot; network = google_compute_network.vpc_network.name allow { protocol = &quot;tcp&quot; ports = [&quot;22&quot;] } // Allow traffic from everywhere to instances with an ssh-server tag source_ranges = [&quot;0.0.0.0/0&quot;] target_tags = [&quot;ssh-server&quot;] } output &quot;ip&quot; { value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip } Create terraform.tfvars file Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode): gce_ssh_user =&quot;sans&quot; gce_ssh_pub_key_file = &quot;~/.ssh/id_rsa.pub&quot; gcp_project = &quot;PROJECT_ID&quot; gcp_region = &quot;us-central1&quot; gcp_zone = &quot;us-central1-a&quot; gcp_key_file = &quot;~/accesskey/service_account.json&quot; NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo. Perform Initial Deployment Run the following command to initialize terraform: terraform init You will see something like: ubuntu@ubuntu:~$ terraform init Initializing the backend... Initializing provider plugins... - Finding latest version of hashicorp/google... - Installing hashicorp/google v3.65.0... - Installed hashicorp/google v3.65.0 (signed by HashiCorp) Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run &quot;terraform init&quot; in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. Now push out the configuration to GCP: terraform apply Upon completion, we will see results that look similar to: SSH into the new GCE instance SSH into the GCE instance using the following command but substituting the output of the terraform script to “IP_ADDRESS” ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS Clean up Now that we have completed the demo, clean up by doing the following: Exit from the SSH Session Run terraform destroy to tear down the GCE resources Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN” Wrap Up That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care." />
<meta property="og:description" content="4 - Use Terraform to Provision a Google Compute instance Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Use Terraform to Provision a Google Compute instance” This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code. Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance. That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently. Generate a SSH Key Pair for Use in this Demo First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like: ubuntu@ubuntu:~$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/ubuntu/.ssh/id_rsa Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub The key fingerprint is: SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223 The key&#39;s randomart image is: +---[RSA 3072]----+ | o.@Xo | | o o O+*E | | o * X o | | B = = | | + S + + | | . + = = | | . o * . | | o.+ o | | .+*= . | +----[SHA256]-----+ This creates the two files in the .ssh directory: id_rsa id_rsa.pub We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown: ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu Note that your public key material will be different than what is shown above. This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance. Create a GCP Project and a Service Account Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique. Create a service account named “terraform” Attach the “Compute Admin” role to the service account. Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.” Select “JSON” as the format and click “CREATE.” This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected. NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted. Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json” For more information see Getting started with Terraform on Google Cloud. Enable The GCE Service Since this is a new project, we will need to enable the GCE service via the web console. Install Terraform Run the following commands to download and install terraform: sudo apt install -y unzip wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip sudo unzip /tmp/terraform.zip -d /usr/local/bin/ rm /tmp/terraform.zip confirm the version and execution: terraform --version You should see the following: ubuntu@unbuntu:~$ terraform --version Terraform v0.15.1 on linux_amd64 Create main.tf file Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode): variable &quot;gce_ssh_user&quot; {} variable &quot;gce_ssh_pub_key_file&quot; {} variable &quot;gcp_project&quot; {} variable &quot;gcp_region&quot; {} variable &quot;gcp_zone&quot; {} variable &quot;gcp_key_file&quot; {} provider &quot;google&quot; { credentials = file(var.gcp_key_file) project = var.gcp_project region = var.gcp_region zone = var.gcp_zone } resource &quot;google_compute_address&quot; &quot;static&quot; { name = &quot;ipv4-address&quot; } resource &quot;google_compute_instance&quot; &quot;vm_instance&quot; { name = &quot;terraform-instance&quot; machine_type = &quot;f1-micro&quot; boot_disk { initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-2004-focal-v20210415&quot; } } network_interface { network = google_compute_network.vpc_network.self_link access_config { nat_ip = google_compute_address.static.address } } metadata = { sshKeys = &quot;${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}&quot; } tags = [&quot;ssh-server&quot;] } resource &quot;google_compute_network&quot; &quot;vpc_network&quot; { name = &quot;vpc-network&quot; auto_create_subnetworks = &quot;true&quot; } resource &quot;google_compute_firewall&quot; &quot;ssh-server&quot; { name = &quot;default-allow-ssh-terraform&quot; network = google_compute_network.vpc_network.name allow { protocol = &quot;tcp&quot; ports = [&quot;22&quot;] } // Allow traffic from everywhere to instances with an ssh-server tag source_ranges = [&quot;0.0.0.0/0&quot;] target_tags = [&quot;ssh-server&quot;] } output &quot;ip&quot; { value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip } Create terraform.tfvars file Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode): gce_ssh_user =&quot;sans&quot; gce_ssh_pub_key_file = &quot;~/.ssh/id_rsa.pub&quot; gcp_project = &quot;PROJECT_ID&quot; gcp_region = &quot;us-central1&quot; gcp_zone = &quot;us-central1-a&quot; gcp_key_file = &quot;~/accesskey/service_account.json&quot; NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo. Perform Initial Deployment Run the following command to initialize terraform: terraform init You will see something like: ubuntu@ubuntu:~$ terraform init Initializing the backend... Initializing provider plugins... - Finding latest version of hashicorp/google... - Installing hashicorp/google v3.65.0... - Installed hashicorp/google v3.65.0 (signed by HashiCorp) Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run &quot;terraform init&quot; in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. Now push out the configuration to GCP: terraform apply Upon completion, we will see results that look similar to: SSH into the new GCE instance SSH into the GCE instance using the following command but substituting the output of the terraform script to “IP_ADDRESS” ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS Clean up Now that we have completed the demo, clean up by doing the following: Exit from the SSH Session Run terraform destroy to tear down the GCE resources Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN” Wrap Up That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care." />
<link rel="canonical" href="http://localhost:4000/episodes/episode04/" />
<meta property="og:url" content="http://localhost:4000/episodes/episode04/" />
<meta property="og:site_name" content="Head in the Clouds" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-24T15:17:05-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Episode 4 - Use Terraform to Provision a Google Compute instance" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-24T14:59:38-03:00","datePublished":"2022-05-24T15:17:05-03:00","description":"4 - Use Terraform to Provision a Google Compute instance Welcome to Episode 4 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Use Terraform to Provision a Google Compute instance” This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code. Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called “Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.” That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance. That video can be found at https://youtu.be/5L6yxXXn0-I. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently. Generate a SSH Key Pair for Use in this Demo First, we need to generate a SSH key pair. Simply type ssh-keygen at the prompt and accept the defaults. The output will look something like: ubuntu@ubuntu:~$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/ubuntu/.ssh/id_rsa Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub The key fingerprint is: SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223 The key&#39;s randomart image is: +---[RSA 3072]----+ | o.@Xo | | o o O+*E | | o * X o | | B = = | | + S + + | | . + = = | | . o * . | | o.+ o | | .+*= . | +----[SHA256]-----+ This creates the two files in the .ssh directory: id_rsa id_rsa.pub We can examine the contents of the public key using cat .ssh/id_rsa.pub as shown: ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu Note that your public key material will be different than what is shown above. This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance. Create a GCP Project and a Service Account Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique. Create a service account named “terraform” Attach the “Compute Admin” role to the service account. Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.” Select “JSON” as the format and click “CREATE.” This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected. NOTE: For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted. Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json” For more information see Getting started with Terraform on Google Cloud. Enable The GCE Service Since this is a new project, we will need to enable the GCE service via the web console. Install Terraform Run the following commands to download and install terraform: sudo apt install -y unzip wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip sudo unzip /tmp/terraform.zip -d /usr/local/bin/ rm /tmp/terraform.zip confirm the version and execution: terraform --version You should see the following: ubuntu@unbuntu:~$ terraform --version Terraform v0.15.1 on linux_amd64 Create main.tf file Using a text editor such as vim or nano, create a file called main.tf and insert the following contents (from the show notes webpage for this episode): variable &quot;gce_ssh_user&quot; {} variable &quot;gce_ssh_pub_key_file&quot; {} variable &quot;gcp_project&quot; {} variable &quot;gcp_region&quot; {} variable &quot;gcp_zone&quot; {} variable &quot;gcp_key_file&quot; {} provider &quot;google&quot; { credentials = file(var.gcp_key_file) project = var.gcp_project region = var.gcp_region zone = var.gcp_zone } resource &quot;google_compute_address&quot; &quot;static&quot; { name = &quot;ipv4-address&quot; } resource &quot;google_compute_instance&quot; &quot;vm_instance&quot; { name = &quot;terraform-instance&quot; machine_type = &quot;f1-micro&quot; boot_disk { initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-2004-focal-v20210415&quot; } } network_interface { network = google_compute_network.vpc_network.self_link access_config { nat_ip = google_compute_address.static.address } } metadata = { sshKeys = &quot;${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}&quot; } tags = [&quot;ssh-server&quot;] } resource &quot;google_compute_network&quot; &quot;vpc_network&quot; { name = &quot;vpc-network&quot; auto_create_subnetworks = &quot;true&quot; } resource &quot;google_compute_firewall&quot; &quot;ssh-server&quot; { name = &quot;default-allow-ssh-terraform&quot; network = google_compute_network.vpc_network.name allow { protocol = &quot;tcp&quot; ports = [&quot;22&quot;] } // Allow traffic from everywhere to instances with an ssh-server tag source_ranges = [&quot;0.0.0.0/0&quot;] target_tags = [&quot;ssh-server&quot;] } output &quot;ip&quot; { value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip } Create terraform.tfvars file Follow a similar process to create a file called terraform.tfvars and insert the following contents (from the show notes webpage for this episode): gce_ssh_user =&quot;sans&quot; gce_ssh_pub_key_file = &quot;~/.ssh/id_rsa.pub&quot; gcp_project = &quot;PROJECT_ID&quot; gcp_region = &quot;us-central1&quot; gcp_zone = &quot;us-central1-a&quot; gcp_key_file = &quot;~/accesskey/service_account.json&quot; NOTE: Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo. Perform Initial Deployment Run the following command to initialize terraform: terraform init You will see something like: ubuntu@ubuntu:~$ terraform init Initializing the backend... Initializing provider plugins... - Finding latest version of hashicorp/google... - Installing hashicorp/google v3.65.0... - Installed hashicorp/google v3.65.0 (signed by HashiCorp) Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run &quot;terraform init&quot; in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. Now push out the configuration to GCP: terraform apply Upon completion, we will see results that look similar to: SSH into the new GCE instance SSH into the GCE instance using the following command but substituting the output of the terraform script to “IP_ADDRESS” ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS Clean up Now that we have completed the demo, clean up by doing the following: Exit from the SSH Session Run terraform destroy to tear down the GCE resources Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN” Wrap Up That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out https://youtu.be/5L6yxXXn0-I for a more detailed explanation of Terraform. If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to head-in-the-clouds-security@googlegroups.com. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist sans.org/CloudSecNextSummit for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care.","headline":"Episode 4 - Use Terraform to Provision a Google Compute instance","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/episodes/episode04/"},"url":"http://localhost:4000/episodes/episode04/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K6EX94SG73"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K6EX94SG73');
</script>


</head>

<body class="page">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		
		<a href="/">Head in the Clouds</a>
		
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				    
				    <li><a href="/" >Home</a></li>
				
				    
				    <li><a href="/episodes/" >All Episodes</a></li>
				
				    
				    <li><a href="https://www.sans.org/cyber-security-courses/?focus-area=cloud-security" target="_blank">SANS CyberSec Courses & Certs</a></li>
				
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main">
  <div class="article-author-side">
    

<div itemscope itemtype="https://schema.org/Person">


	<img src="/images/Cloud_Ace_Final.png" class="bio-photo" alt="Head in the Clouds bio photo">


  <h3 itemprop="name">Head in the Clouds</h3>
  <p>with Kenneth G. Hartman<p>Certified SANS Instructor</p>
  <a href="mailto:kgh@kennethghartman.com" class="author-social" target="_blank"><i class="fa fa-fw fa-envelope-square"></i> Email</a>
  <a href="https://twitter.com/kennethghartman" class="author-social" target="_blank"><i class="fa fa-fw fa-twitter-square"></i> Twitter</a>
  
  
  
  
  
  
  
  <a href="https://github.com/Resistor52" class="author-social" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </div>
  <article class="page">
    <h1>Episode 4 - Use Terraform to Provision a Google Compute instance</h1>
    <div class="article-wrap">
      <p>4 - Use Terraform to Provision a Google Compute instance</p>

<div class="video-container"><iframe src="https://www.youtube.com/embed/pTOKkxnaDyk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>

<p>Welcome to Episode 4 of the <em>“Head in the Clouds”</em> Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.</p>

<p>Today’s episode is titled: <em>“Use Terraform to Provision a Google Compute instance”</em></p>

<p>This video is a demonstration on how to deploy a Google Compute Engine instance using terraform, complete with sample code.</p>

<p>Back in March of this year (2021), I did a 90 minute SANS Tech Tuesday workshop called <em>“Use Terraform to Provision Your Own Cloud Based Remote Browsing Workstation.”</em> That workshop was essentially a tutorial on using both Terraform and Github to create a configured AWS Elastic Compute Instance.</p>

<p>That video can be found at <a href="https://youtu.be/5L6yxXXn0-I">https://youtu.be/5L6yxXXn0-I</a>. Since the Tech Tuesday workshop was focused on AWS, I decided to do this episode of “Head in the Clouds” as a follow-up and focus on deploying a GCE instance, since the Terraform provider and access control work differently.</p>

<h2 id="generate-a-ssh-key-pair-for-use-in-this-demo">Generate a SSH Key Pair for Use in this Demo</h2>

<p>First, we need to generate a SSH key pair. Simply type <code class="language-plaintext highlighter-rouge">ssh-keygen</code> at the prompt and accept the defaults. The output will look something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@ubuntu:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:1HXgtAWZAYtmuP6vRE9r7uLfRDC5SLjzbWVgLhU3E9k ubuntu@ip-172-31-90-223
The key's randomart image is:
+---[RSA 3072]----+
|          o.@Xo  |
|       o o O+*E  |
|      o * X o    |
|       B = =     |
|      + S + +    |
|     . + = =     |
|      . o * .    |
|       o.+ o     |
|       .+*= .    |
+----[SHA256]-----+

</code></pre></div></div>

<p>This creates the two files in the .ssh directory:</p>
<ul>
  <li>id_rsa</li>
  <li>id_rsa.pub</li>
</ul>

<p>We can examine the contents of the public key using <code class="language-plaintext highlighter-rouge">cat .ssh/id_rsa.pub</code> as shown:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@ubuntu:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDbcBCogxJw6vWLYJxQVA1NP/PbmrNc4QL8upLqvmSN/kn03Jiw+iOr2pxIZwjLMHI5xGtndlIstNjh6wEjzH1YexZvtrf5Gw0BLf144k7YN1Yig6p/nbEUbKhEsIIQV77pOUhqdcJFGNg0AxBLzeZ7uCDDzYyTQtjIiGSKf4e8ATcnnZyP9viMI1LBEDJItwra/v1nM5OWS54U7bj8APwYzEYYVX84cj/reHl48gSmwj5G2kOwtAJwegU5oTt2Y3gsiteTxT0GMXgVM5qigns1TBVjsW749YtHcTv4PApRRCxkdE468b9uaY/jgu4Fic7u6KcE4vay2EKS7GpobXntU/iLqX1SQetG2D1YW/dH7OivIMBNJ5dxXDEDMhXwfTeW+bA3VR7e7BGK8GXRAIY9u7z2zLLauV4RC8fyLgXFnxPth2bqNiDww11l21wLHUjsrJ4djg4wltMktvvMdtUzXJ0nIwUQXSFsyRxDYXW/xgtQ+udcsVfvCEDklMmycbM= ubuntu@ubuntu
</code></pre></div></div>

<p>Note that your public key material will be different than what is shown above.</p>

<p>This key will be inserted into our GCE instance at boot time by Terraform. The private key (id_rsa) will be used by the SSH client to authenticate to this GCE instance.</p>

<h2 id="create-a-gcp-project-and-a-service-account">Create a GCP Project and a Service Account</h2>

<p>Next, lets create a dedicated GCP project and a Service Account. Log into the GCP Cloud Console and create a new project. Use a name similar to “tf-gcp-“ plus six random digits so that the project name is globally unique.</p>

<p><img src="/images/ep4/Picture2.png" alt="Image of the GCP console creating a new project" /></p>

<p>Create a service account named “terraform”</p>

<p><img src="/images/ep4/Picture3.png" alt="Image of the GCP console creating a new role" /></p>

<p>Attach the “Compute Admin” role to the service account.</p>

<p><img src="/images/ep4/Picture4a.png" alt="Image of the GCP console assigning a role to the new service account" /></p>

<p>Click “Done.” Next, click “Manage Keys” under the Actions heading. Then click “ADD KEY” and select “Create new key.”</p>

<p>Select “JSON” as the format and click “CREATE.”</p>

<p><img src="/images/ep4/Picture5.png" alt="Image of the GCP console creating a json key for the service account" /></p>

<p>This will generate a JSON file that grants the holder full access to the project, so it must be carefully protected.</p>

<p><strong>NOTE:</strong> For the purposes of this demo, I will be exposing my key. But by the time you view this video the key pair and the GCP project will have been deleted.</p>

<p><img src="/images/ep4/Picture1a.png" alt="Image of the service account key file" /></p>

<p>Next, I am going to move a copy of this key onto my Ubuntu system, placing it in a directory called “accesskey” and renaming the file “service_account.json”</p>

<p>For more information see <a href="https://cloud.google.com/community/tutorials/getting-started-on-gcp-with-terraform">Getting started with Terraform on Google Cloud</a>.</p>

<h2 id="enable-the-gce-service">Enable The GCE Service</h2>

<p>Since this is a new project, we will need to enable the GCE service via the web console.</p>

<p><img src="/images/ep4/Picture6.png" alt="Image of the GCP console enabling the Compute Engine API" /></p>

<h2 id="install-terraform">Install Terraform</h2>

<p>Run the following commands to download and install terraform:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install -y unzip
wget https://releases.hashicorp.com/terraform/0.15.1/terraform_0.15.1_linux_amd64.zip -O /tmp/terraform.zip
sudo unzip /tmp/terraform.zip -d /usr/local/bin/
rm /tmp/terraform.zip
</code></pre></div></div>

<p>confirm the version and execution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>terraform --version
</code></pre></div></div>

<p>You should see the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@unbuntu:~$ terraform --version
Terraform v0.15.1
on linux_amd64
</code></pre></div></div>

<h2 id="create-maintf-file">Create main.tf file</h2>

<p>Using a text editor such as vim or nano, create a file called <code class="language-plaintext highlighter-rouge">main.tf</code> and insert the following contents (from the show notes webpage for this episode):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>variable "gce_ssh_user" {}
variable "gce_ssh_pub_key_file" {}
variable "gcp_project" {}
variable "gcp_region" {}
variable "gcp_zone" {}
variable "gcp_key_file" {}

provider "google" {
  credentials = file(var.gcp_key_file)
  project = var.gcp_project
  region  = var.gcp_region
  zone    = var.gcp_zone
}

resource "google_compute_address" "static" {
  name = "ipv4-address"
}

resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"

  boot_disk {
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-2004-focal-v20210415"
    }
  }

  network_interface {
    network = google_compute_network.vpc_network.self_link
    access_config {
      nat_ip = google_compute_address.static.address
      }
  }

metadata = {
  sshKeys = "${var.gce_ssh_user}:${file(var.gce_ssh_pub_key_file)}"
  }

tags = ["ssh-server"]

}

resource "google_compute_network" "vpc_network" {
  name                    = "vpc-network"
  auto_create_subnetworks = "true"
}

resource "google_compute_firewall" "ssh-server" {
  name    = "default-allow-ssh-terraform"
  network = google_compute_network.vpc_network.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  // Allow traffic from everywhere to instances with an ssh-server tag
  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

output "ip" {
  value = google_compute_instance.vm_instance.network_interface.0.access_config.0.nat_ip
}

</code></pre></div></div>

<h2 id="create-terraformtfvars-file">Create terraform.tfvars file</h2>

<p>Follow a similar process to create a file called <code class="language-plaintext highlighter-rouge">terraform.tfvars</code> and insert the following contents (from the show notes webpage for this episode):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gce_ssh_user ="sans"
gce_ssh_pub_key_file = "~/.ssh/id_rsa.pub"
gcp_project = "PROJECT_ID"
gcp_region  = "us-central1"
gcp_zone    = "us-central1-a"
gcp_key_file = "~/accesskey/service_account.json"

</code></pre></div></div>

<p><strong>NOTE:</strong> Be sure to replace PROJECT_ID with the project id that was created at the beginning of this demo.</p>

<h2 id="perform-initial-deployment">Perform Initial Deployment</h2>

<p>Run the following command to initialize terraform:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>terraform init
</code></pre></div></div>

<p>You will see something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@ubuntu:~$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/google...
- Installing hashicorp/google v3.65.0...
- Installed hashicorp/google v3.65.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.

</code></pre></div></div>

<p>Now push out the configuration to GCP:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>terraform apply
</code></pre></div></div>

<p>Upon completion, we will see results that look similar to:</p>

<p><img src="/images/ep4/Picture7.png" alt="Image of terminal showing the last portion of the Terraform output" /></p>

<h2 id="ssh-into-the-new-gce-instance">SSH into the new GCE instance</h2>

<p>SSH into the GCE instance using the following command but substituting the output of the
terraform script to “IP_ADDRESS”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -i ~/.ssh/id_rsa sans@IP_ADDRESS
</code></pre></div></div>

<h2 id="clean-up">Clean up</h2>
<p>Now that we have completed the demo, clean up by doing the following:</p>
<ol>
  <li>Exit from the SSH Session</li>
  <li>Run <code class="language-plaintext highlighter-rouge">terraform destroy</code> to tear down the GCE resources</li>
  <li>Destroy the GCP project by navigating to “IAM &amp; Admin” in the Web Console and selecting “settings.” Then click “SHUTDOWN”</li>
</ol>

<h2 id="wrap-up">Wrap Up</h2>

<p>That’s it! Now you know the basics of provisioning a Google Compute Engine virtual machine. This lays the foundation for future episodes where we will use this Infrastructure as Code (IaC). Remember to check out <a href="https://youtu.be/5L6yxXXn0-I">https://youtu.be/5L6yxXXn0-I</a> for a more detailed explanation of Terraform.</p>

<p>If you have thoughts or comments on today’s episode, feel free to chime in on our moderated Google Group by shooting a note to <a href="mailto://head-in-the-clouds-security@googlegroups.com">head-in-the-clouds-security@googlegroups.com</a>.</p>

<p>If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”</p>

<p>I also want to announce that we have the SANS CloudSecNext Summit comming up in June, on 6/3-6/4. Vist <a href="sans.org/CloudSecNextSummit">sans.org/CloudSecNextSummit</a> for details and to register. We are anticipating upwards of 10,000 attendees. I will be a chair of one of the tracks. I’m looking forward to this, these summits are always lots of fun and a great source of information.</p>

<p><img src="/images/ep4/SUMMIT_CloudSecNext Slide.png" alt="Image announcing the SANS CloudSecNext Summit" /></p>

<p>Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the <a href="https://twitter.com/SANSCloudSec">SANS Cloud Security Twitter feed</a>.</p>

<p>Meanwhile, be sure to check out the other great videos on the <a href="https://www.youtube.com/c/SANSCloudSecurity">SANS Cloud Security YouTube Channel</a>.</p>

<p>Take care.</p>

      
        <hr />
        <div class="social-share">
  <!--<h4>Share on</h4>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=/episodes/episode04/" class="twitter" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=/episodes/episode04/" class="facebook" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=/episodes/episode04/" class="google-plus" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
  </ul>-->
</div><!-- /.social-share -->

      
    </div><!-- /.article-wrap -->
    
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    

<span>&copy; 2022 Head in the Clouds.<br /></span>


  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-25220220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




</body>
</html>
