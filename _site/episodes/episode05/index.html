<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<html>
<head>
<meta charset="utf-8">


<title>Episode 5 - Tips for success with Command Line Interfaces using BASH &mdash; Head in the Clouds</title>
<meta name="description" content="5 - Tips for success with Command Line Interfaces using BASH



Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.”

The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors.

Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well.

First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.”

Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it.
The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1].

BASH History

One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history.

To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command.



To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5.



This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it.



Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files.

Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history

To view the file listing, type ls -la ~/.bash_history

Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls



In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files.



Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen.



Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory.
This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history



BASH Variables

BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time.

To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning.



Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string.

If I open up a new terminal session, the value of the SANS variable has not been set.

Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that:



Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command.



Great. Now let’s check out our environment variables:



Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service.



To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown:

export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7
export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2


And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID.



Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3].

Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it.



When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way!

Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.”

Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt.

There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several:  https://ss64.com/bash/syntax-keyboard.html.

Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient.

Wrap Up

That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables.

If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4.

Visit sans.org/CloudSecNextSummit for details and to register.
 It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.



[1] https://opensource.com/19/9/command-line-heroes-bash

[2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/

[3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

[4] https://ss64.com/bash/syntax-keyboard.html
">
<meta name="keywords" content="">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Episode 5 - Tips for success with Command Line Interfaces using BASH">
<meta name="twitter:description" content="5 - Tips for success with Command Line Interfaces using BASH



Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.”

The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors.

Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well.

First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.”

Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it.
The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1].

BASH History

One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history.

To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command.



To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5.



This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it.



Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files.

Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history

To view the file listing, type ls -la ~/.bash_history

Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls



In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files.



Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen.



Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory.
This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history



BASH Variables

BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time.

To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning.



Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string.

If I open up a new terminal session, the value of the SANS variable has not been set.

Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that:



Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command.



Great. Now let’s check out our environment variables:



Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service.



To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown:

export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7
export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2


And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID.



Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3].

Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it.



When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way!

Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.”

Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt.

There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several:  https://ss64.com/bash/syntax-keyboard.html.

Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient.

Wrap Up

That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables.

If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4.

Visit sans.org/CloudSecNextSummit for details and to register.
 It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.



[1] https://opensource.com/19/9/command-line-heroes-bash

[2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/

[3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

[4] https://ss64.com/bash/syntax-keyboard.html
">
<meta name="twitter:site" content="@kennethghartman">
<meta name="twitter:creator" content="@kennethghartman">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/default-thumb.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Episode 5 - Tips for success with Command Line Interfaces using BASH">
<meta property="og:description" content="5 - Tips for success with Command Line Interfaces using BASH



Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.

Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.”

The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors.

Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well.

First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.”

Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it.
The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1].

BASH History

One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history.

To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command.



To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5.



This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it.



Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files.

Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history

To view the file listing, type ls -la ~/.bash_history

Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls



In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files.



Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen.



Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory.
This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history



BASH Variables

BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time.

To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning.



Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string.

If I open up a new terminal session, the value of the SANS variable has not been set.

Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that:



Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command.



Great. Now let’s check out our environment variables:



Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service.



To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown:

export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7
export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2


And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID.



Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3].

Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it.



When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way!

Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.”

Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt.

There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several:  https://ss64.com/bash/syntax-keyboard.html.

Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient.

Wrap Up

That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables.

If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video.

If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”

I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4.

Visit sans.org/CloudSecNextSummit for details and to register.
 It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information.



Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.

Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.

Take care.



[1] https://opensource.com/19/9/command-line-heroes-bash

[2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/

[3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html

[4] https://ss64.com/bash/syntax-keyboard.html
">
<meta property="og:url" content="/episodes/episode05/">
<meta property="og:site_name" content="Head in the Clouds">

<meta property="og:image" content="/images/default-thumb.png">






<link rel="canonical" href="/episodes/episode05/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Head in the Clouds Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">


<meta http-equiv="cleartype" content="on">


<!-- Modernizr -->
<script src="/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/css/academicons/css/academicons.css"/>
<!-- Icons -->
<!-- 16x16 -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!--Jekyll-seo plugin-->
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Episode 5 - Tips for success with Command Line Interfaces using BASH | Head in the Clouds</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Episode 5 - Tips for success with Command Line Interfaces using BASH" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="5 - Tips for success with Command Line Interfaces using BASH Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.” The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors. Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well. First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.” Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it. The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1]. BASH History One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history. To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command. To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5. This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it. Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files. Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history To view the file listing, type ls -la ~/.bash_history Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files. Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen. Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory. This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history BASH Variables BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time. To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning. Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string. If I open up a new terminal session, the value of the SANS variable has not been set. Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that: Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command. Great. Now let’s check out our environment variables: Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service. To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown: export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7 export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2 And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID. Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3]. Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it. When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way! Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.” Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt. There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several: https://ss64.com/bash/syntax-keyboard.html. Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient. Wrap Up That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables. If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4. Visit sans.org/CloudSecNextSummit for details and to register. It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care. [1] https://opensource.com/19/9/command-line-heroes-bash [2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/ [3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html [4] https://ss64.com/bash/syntax-keyboard.html" />
<meta property="og:description" content="5 - Tips for success with Command Line Interfaces using BASH Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.” The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors. Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well. First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.” Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it. The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1]. BASH History One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history. To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command. To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5. This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it. Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files. Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history To view the file listing, type ls -la ~/.bash_history Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files. Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen. Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory. This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history BASH Variables BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time. To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning. Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string. If I open up a new terminal session, the value of the SANS variable has not been set. Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that: Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command. Great. Now let’s check out our environment variables: Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service. To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown: export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7 export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2 And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID. Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3]. Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it. When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way! Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.” Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt. There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several: https://ss64.com/bash/syntax-keyboard.html. Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient. Wrap Up That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables. If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4. Visit sans.org/CloudSecNextSummit for details and to register. It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care. [1] https://opensource.com/19/9/command-line-heroes-bash [2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/ [3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html [4] https://ss64.com/bash/syntax-keyboard.html" />
<link rel="canonical" href="http://localhost:4000/episodes/episode05/" />
<meta property="og:url" content="http://localhost:4000/episodes/episode05/" />
<meta property="og:site_name" content="Head in the Clouds" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-24T15:17:05-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Episode 5 - Tips for success with Command Line Interfaces using BASH" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-24T14:59:39-03:00","datePublished":"2022-05-24T15:17:05-03:00","description":"5 - Tips for success with Command Line Interfaces using BASH Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum. Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.” The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors. Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “Public Cloud Security: AWS, Azure, and GCP” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well. First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.” Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it. The full name of BASH is the Bourne Again Shell. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1]. BASH History One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history. To view the commands that have been run recently, just type history and you will see a numbered list with the highest number being the last command. To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the whoami command, I can just type “bang” 5. This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the cat command to look at the contents of a text file recently but forgot the path, we could use history | grep cat to find it. Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files. Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called .bash_history To view the file listing, type ls -la ~/.bash_history Remember that ls is the command to list the directory contents and that you can view the manual page of any command by typing man in front of the command. For example, man ls In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for ls we can see that the l option is to direct the ls command to display the file listing in the long format. We can also see that the a option directs the ls command to output all files that match the FILE specification, including hidden files. Note: Looking at the output of this ls command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the link displayed on screen. Incidentally, .bash_history is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran ls -la ~/.bash_history we told the ls command to look for the .bash_history file in our home directory. This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run cat ~/.bash_history BASH Variables BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time. To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use SANS=488. We can view the contents of the variable using the echo command. Recall that to learn more about the echo command, you can use man echo to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning. Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string. If I open up a new terminal session, the value of the SANS variable has not been set. Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that: Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the env command. Great. Now let’s check out our environment variables: Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service. To set an environment variable, add the export command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown: export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7 export AWS_SECRET_ACCESS_KEY=rkjDr/Wx7BrX+omy+TWQMbvcHCUyYI3bR6dGU7u2 And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID. Checkout https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html for a list of environment variables supported by the AWS CLI [3]. Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the unset command to remove it. When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way! Use Control-A to jump to the beginning of the line and hit Control-E to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.” Many folks know that you can use Control-C to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit Control-C to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt. There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several: https://ss64.com/bash/syntax-keyboard.html. Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient. Wrap Up That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables. If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video. If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.” I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4. Visit sans.org/CloudSecNextSummit for details and to register. It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information. Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed. Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel. Take care. [1] https://opensource.com/19/9/command-line-heroes-bash [2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/ [3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html [4] https://ss64.com/bash/syntax-keyboard.html","headline":"Episode 5 - Tips for success with Command Line Interfaces using BASH","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/episodes/episode05/"},"url":"http://localhost:4000/episodes/episode05/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K6EX94SG73"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K6EX94SG73');
</script>


</head>

<body class="page">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		
		<a href="/">Head in the Clouds</a>
		
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				    
				    <li><a href="/" >Home</a></li>
				
				    
				    <li><a href="/episodes/" >All Episodes</a></li>
				
				    
				    <li><a href="https://www.sans.org/cyber-security-courses/?focus-area=cloud-security" target="_blank">SANS CyberSec Courses & Certs</a></li>
				
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main">
  <div class="article-author-side">
    

<div itemscope itemtype="https://schema.org/Person">


	<img src="/images/Cloud_Ace_Final.png" class="bio-photo" alt="Head in the Clouds bio photo">


  <h3 itemprop="name">Head in the Clouds</h3>
  <p>with Kenneth G. Hartman<p>Certified SANS Instructor</p>
  <a href="mailto:kgh@kennethghartman.com" class="author-social" target="_blank"><i class="fa fa-fw fa-envelope-square"></i> Email</a>
  <a href="https://twitter.com/kennethghartman" class="author-social" target="_blank"><i class="fa fa-fw fa-twitter-square"></i> Twitter</a>
  
  
  
  
  
  
  
  <a href="https://github.com/Resistor52" class="author-social" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </div>
  <article class="page">
    <h1>Episode 5 - Tips for success with Command Line Interfaces using BASH</h1>
    <div class="article-wrap">
      <p>5 - Tips for success with Command Line Interfaces using BASH</p>

<div class="video-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/BwoU9BJeGKU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>

<p>Welcome to Episode 5 of the “Head in the Clouds” Video Series. I am Ken Hartman, a SANS Certified Instructor and content creator for the SANS Cloud Security Curriculum.</p>

<p>Today’s episode is titled: “Tips for success with Command Line Interfaces using BASH.”</p>

<p>The purpose of HITC is to teach foundational cloud skills and security knowledge that will help others thrive in the cloud. The content ideas come from my personal observation of skills that I see some students lacking when they show up to a SANS Cloud Security course. Other ideas are passed on from fellow SANS instructors.</p>

<p>Today’s topic is based on a conversation with SANS Principal Instructor Eric Johnson during a break while co-teaching SEC510 at SANS Security West. The full title of SEC510 is “<a href="https://www.sans.org/cyber-security-courses/public-cloud-security-aws-azure-gcp/">Public Cloud Security: AWS, Azure, and GCP</a>” and throughout the entire class, various Command Line Interface commands are run from the Linux BASH Terminal. This is the case with most of the other classes in the SANS Cloud Security Curriculum as well.</p>

<p>First off, what is the big deal with command line interfaces? Command line interfaces allow one to manipulate a cloud service from a terminal. This is a powerful technique because it is succinct and efficient. It is also easier to copy and paste a single command from a playbook than it is to say, “go to your web console, click on the “X” menu and select “Y” item, then click on the “Z” object, etc.”</p>

<p>Multiple command line interface commands can be combined to make a script. And this is where knowledge of BASH will be payoff as well. And since this is a brief tutorial on BASH, lets jump into it.
The full name of BASH is the <em>Bourne Again Shell</em>. It is the most popular (but not the only shell) that can be used by the Linux Operating System. It has been around since 1989 and is still actively maintained [1].</p>

<h2 id="bash-history">BASH History</h2>

<p>One of the first tricks that a user will figure out, is that they can use the up arrow to revisit the last command that they ran. This is a handy trick, and I use it all of the time. However, I also see new students use the up-arrow dozens of times to access a command that they ran much earlier in their session. This is rather painful, so our first few tricks involve how to access one’s command history.</p>

<p>To view the commands that have been run recently, just type <code class="language-plaintext highlighter-rouge">history</code> and you will see a numbered list with the highest number being the last command.</p>

<p><img src="/images/ep5/history.png" alt="Image of BASH History" /></p>

<p>To execute any of the listed commands simply type an exclamation point and the number that corresponds to the command. So, for example, if I want to rerun the <code class="language-plaintext highlighter-rouge">whoami</code> command, I can just type “bang” 5.</p>

<p><img src="/images/ep5/execute_from_history.png" alt="Execute a command from BASH History" /></p>

<p>This is a great time saver, and very good to know. I can also pipe one command into another. In fact, we can pipe the output of the history command into grep and use that to filter our results. For example, if we used the <code class="language-plaintext highlighter-rouge">cat</code> command to look at the contents of a text file recently but forgot the path, we could use <code class="language-plaintext highlighter-rouge">history | grep cat</code> to find it.</p>

<p><img src="/images/ep5/grep_for_cat.png" alt="Grepping BASH History for a command containing cat" /></p>

<p>Grep is powerful, and we will explore it more in the next edition of HITC along with some other powerful commands for slicing and dicing log files.</p>

<p>Perhaps when you ran the history command just now, you wondered where it pulled its data from? If so, great. Its good to be curious. If you look in your home directory, you will see a file called <code class="language-plaintext highlighter-rouge">.bash_history</code></p>

<p>To view the file listing, type <code class="language-plaintext highlighter-rouge">ls -la ~/.bash_history</code></p>

<p>Remember that <code class="language-plaintext highlighter-rouge">ls</code> is the command to list the directory contents and that you can view the manual page of any command by typing <code class="language-plaintext highlighter-rouge">man</code> in front of the command. For example, <code class="language-plaintext highlighter-rouge">man ls</code></p>

<p><img src="/images/ep5/man_ls.png" alt="Viewing the man page for ls" /></p>

<p>In fact, the best advice that is often given to new users of Linux is to RTFM – Read the Fine Manual. By looking at the man page for <code class="language-plaintext highlighter-rouge">ls</code> we can see that the <code class="language-plaintext highlighter-rouge">l</code> option is to direct the <code class="language-plaintext highlighter-rouge">ls</code> command to display the file listing in the long format. We can also see that the <code class="language-plaintext highlighter-rouge">a</code> option directs the <code class="language-plaintext highlighter-rouge">ls</code> command to output all files that match the FILE specification, including hidden files.</p>

<p><img src="/images/ep5/ls_output.png" alt="Listing the BASH history file using ls" /></p>

<p>Note: Looking at the output of this <code class="language-plaintext highlighter-rouge">ls</code> command, we can see that the permissions on the .bash_history file are read and write by the owner, so this file should not be regarded as a robust audit log. If you are not familiar with Linux permissions, I will refer you to the <a href="https://www.linux.com/training-tutorials/understanding-linux-file-permissions/">link displayed on screen</a>.</p>

<p><img src="/images/ep5/understanding_file_perms.png" alt="Screenshot of Understanding Linux File Permissions article" /></p>

<p>Incidentally, <code class="language-plaintext highlighter-rouge">.bash_history</code> is a hidden file and we can tell this because any filename that starts with a period is a hidden file. By default, the .bash_history for any user is in their home directory. So when we ran <code class="language-plaintext highlighter-rouge">ls -la ~/.bash_history</code> we told the <code class="language-plaintext highlighter-rouge">ls</code> command to look for the .bash_history file in our home directory.
This is because the tilde character is an alias for the $HOME environment variable. We will talk about variables next, but before we move on, let’s take a look at the contents of our .bash_history file. Let’s run <code class="language-plaintext highlighter-rouge">cat ~/.bash_history</code></p>

<p><img src="/images/ep5/cat_bash_history.png" alt="Using cat to view the BASH history file" /></p>

<h2 id="bash-variables">BASH Variables</h2>

<p>BASH has two types of variables—local variables and environment variables. Local variables can be set inside a script or an interactive shell session, but when the script has completed or the shell session as terminated, the variables are released from memory. On the other hand, environment variables are maintained in memory until the system is rebooted, so that other scripts, programs, or shell sessions can access them. Also note that many of the environmental variables are set by start-up scripts that run at boot time.</p>

<p>To set a variable we use an equal sign. For example, to set the value of ‘488’ to a local variable called ‘SANS’ we would use <code class="language-plaintext highlighter-rouge">SANS=488</code>. We can view the contents of the variable using the <code class="language-plaintext highlighter-rouge">echo</code> command. Recall that to learn more about the echo command, you can use <code class="language-plaintext highlighter-rouge">man echo</code> to view its manual page. All of these commands have a multitude of options that make them quite versatile and worth learning.</p>

<p><img src="/images/ep5/echo_sans.png" alt="Accessing a variable" /></p>

<p>Note that when we use the variable, we prepend a dollar sign to access the contents of the variable. Without the dollar sign, the word ‘SANS’ is treated as a string.</p>

<p>If I open up a new terminal session, the value of the SANS variable has not been set.</p>

<p>Earlier in this edition, I mentioned that the tilde character was a shorthand representation for the $HOME environmental variable. Let’s prove that:</p>

<p><img src="/images/ep5/echo_home.png" alt="Comparing the ~ and HOME Variables" /></p>

<p>Since we are talking about environmental variables, you may be wondering what other environmental variables have been set on your system. Well, fortunately, Linux has a command for that as well. Use the man command to learn more about the <code class="language-plaintext highlighter-rouge">env</code> command.</p>

<p><img src="/images/ep5/man_env.png" alt="Viewing the man page for env" /></p>

<p>Great. Now let’s check out our environment variables:</p>

<p><img src="/images/ep5/env.png" alt="Viewing the env output" /></p>

<p>Notice the HOME, PWD, USER, and PATH variables. These are used by the operating system to keep track of specifics about the user’s environment. Many command line interfaces will use environment variables to set credentials that the CLI will use to authenticate to the cloud service.</p>

<p><img src="/images/ep5/grep_env.png" alt="Grepping the env output" /></p>

<p>To set an environment variable, add the <code class="language-plaintext highlighter-rouge">export</code> command in front of the assignment statement. For example, with AWS, I can set two environment variables with valid a access key id and access key secret as shown:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export AWS_ACCESS_KEY_ID=AKIA2PRSBJQH7AVO5KX7
export AWS_SECRET_ACCESS_KEY=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
</code></pre></div></div>

<p>And that will allow me to run various AWS CLI commands as allowed by the permissions associated with the identity tied to the AWS Access Key ID.</p>

<p><img src="/images/ep5/aws_s3_ls.png" alt="Running the aws s3 ls command" /></p>

<p>Checkout <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html">https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html</a> for a list of environment variables supported by the AWS CLI [3].</p>

<p>Sometimes it may be necessary to change or remove an environment variable. To change a variable, just set the same variable to a different value. Use the <code class="language-plaintext highlighter-rouge">unset</code> command to remove it.</p>

<p><img src="/images/ep5/unset.png" alt="Unset an environment variable" /></p>

<p>When helping SANS students, I have often seen them hitting the right arrow many times to get to the end of the command line or hitting the left arrow key multiple times to get to the beginning. There is an easier way!</p>

<p>Use <strong>Control-A</strong> to jump to the beginning of the line and hit <strong>Control-E</strong> to jump to the end of the line. I use the following memory trick: the letter “A” is at the beginning of the alphabet and “E” is for “End.”</p>

<p>Many folks know that you can use <strong>Control-C</strong> to “cancel” a program that is running from the command line. But you can also do this if you mess up typing a command. Just hit <strong>Control-C</strong> to cancel it rather than backspacing to the beginning of the line. When you do so, you will be returned to an empty prompt.</p>

<p>There are many more BASH terminal shortcuts, so as we close, I will leave you with good reference that lists several:  <a href="https://ss64.com/bash/syntax-keyboard.html">https://ss64.com/bash/syntax-keyboard.html</a>.</p>

<p>Of course, to remember them, you have to use them! So, practice one at a time until it becomes second nature. Over time, you will thank yourself for becoming more efficient.</p>

<h2 id="wrap-up">Wrap Up</h2>

<p>That’s it! Now you know some tips and tricks that will help you navigate the BASH Shell and how to work with environment variables.</p>

<p>If you have thoughts or comments on today’s episode, feel free to chime in on the comments for this YouTube video.</p>

<p>If you appreciate this video and want to see more like it, be sure to give it a “thumbs up.”</p>

<p>I also want to mention that we have the SANS CloudSecNext Summit coming up quickly. It runs next week. That is June 3-4.</p>

<p>Visit <a href="https://www.sans.org/event/cloudsecnext-summit-2021/">sans.org/CloudSecNextSummit</a> for details and to register.
 It’s not too late and, best of all the Summit is free. We are anticipating upwards of 10,000 attendees. I will be a chair of the Solutions Track. We always have lots of fun at these summits and they are packed with great information.</p>

<p><img src="/images/ep4/SUMMIT_CloudSecNext Slide.png" alt="Image announcing the SANS CloudSecNext Summit" /></p>

<p>Stay tuned for another installment of “Head in the Clouds” as announcements of new episodes are made on the SANS Cloud Security Twitter feed.</p>

<p>Meanwhile, be sure to check out the other great videos on the SANS Cloud Security YouTube Channel.</p>

<p>Take care.</p>

<hr />

<p>[1] https://opensource.com/19/9/command-line-heroes-bash</p>

<p>[2] https://www.linux.com/training-tutorials/understanding-linux-file-permissions/</p>

<p>[3] https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html</p>

<p>[4] https://ss64.com/bash/syntax-keyboard.html</p>

      
        <hr />
        <div class="social-share">
  <!--<h4>Share on</h4>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=/episodes/episode05/" class="twitter" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=/episodes/episode05/" class="facebook" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=/episodes/episode05/" class="google-plus" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
  </ul>-->
</div><!-- /.social-share -->

      
    </div><!-- /.article-wrap -->
    
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    

<span>&copy; 2022 Head in the Clouds.<br /></span>


  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-25220220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




</body>
</html>
